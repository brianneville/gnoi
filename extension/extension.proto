syntax = "proto3";

package gnoi.extension;

import "types/types.proto";

option go_package = "github.com/openconfig/gnoi/extension";

option (types.gnoi_version) = "0.1.0";

// Extension is a service for managing extensions on the system.
// An extension is a collection of files (e.g. RPMs, squashfs)
// which are installed to modify the behaviour of the services on the
// system.
// Only one RPC (SetSignatureVerification, FinalizeExtensions,
// InstallExtension, UninstallExtension)
// may be in progress at any given time
service Extension{

  // Shows the current state of the extensions on the system.
  rpc ShowExtensions(ShowExtensionsRequest)returns (ShowExtensionsResponse);

  // FinalizeExtensions reloads any services on the system for
  // which extensions have been installed but which have not yet been
  // reloaded with those extensions.
  // Please note that this may kill the connection if the service
  // hosting the gRPC server reloads so the server is not guaranteed
  // to return a response here.
  rpc FinalizeExtensions(FinalizeExtensionsRequest)
      returns (FinalizeExtensionsResponse);

  // InstallExtension installs a new extension on the system.
  // The new extension may be transferred as part of the RPC.
  //
  // Expected workflows are:
  // 1. To transfer a new extension:
  // client ______________________________________ server
  // TransferRequest (with extension_name set) -->
  // TransferRequest (with contents set)       -->
  // .. repeated TransferRequest with contents are sent
  //  until the file is transferred ..
  // TransferRequest (with hash set)           -->
  // .. server verifies hash matches expected ..
  //                                           <-- InstallExtensionResponse
  //                             (with acknowledgement = TRANSFER_COMPLETE)
  // STREAM END
  //
  // 2. To transfer and install a new extension:
  // client ______________________________________ server
  // TransferRequest (with extension_name set) -->
  // TransferRequest (with contents set)       -->
  // .. repeated TransferRequest with contents are sent
  // until the file is transferred ..
  // TransferRequest (with hash set)           -->
  // .. server verifies hash matches expected ..
  //                                           <-- InstallExtensionResponse
  //                             (with acknowledgement = TRANSFER_COMPLETE)
  // InstallRequest (with extension_name set)  -->
  // (note, other fields may be set )
  // .. server installs extension according to fields.
  //                                           <-- InstallExtensionResponse
  //                              (with acknowledgement = INSTALL_COMPLETE)
  // STREAM END
  //
  // 3. To install a pre-existing extension:
  // client ______________________________________ server
  // InstallRequest (with extension_name set)
  // (note, other fields may be set )          -->
  // .. server installs extension according to fields.
  //                                           <-- InstallExtensionResponse
  //                              (with acknowledgement = INSTALL_COMPLETE)
  // STREAM END
  // Note that all installations will install the extension, but that
  // extension will not be applied until the affected services are reloaded.
  // To reload services after installing extensions, issue a
  // FinalizeExtensions RPC after finishing the InstallExtension RPC.
  rpc InstallExtension(stream InstallExtensionRequest)
      returns (stream InstallExtensionResponse);

  // UninstallExtension uninstalls an extension.
  // It returns an error if the requested extension is not installed.
  rpc UninstallExtension(UninstallExtensionRequest)
      returns (UninstallExtensionResponse);
}

message ShowExtensionsRequest{}
message ShowExtensionsResponse{
  enum InstallStatus {
    // UNSPECIFIED should be treated as an error.
    UNSPECIFIED = 0;
    INSTALLED = 1;
    NOT_INSTALLED = 2;

    // This extension was force-installed - checks regarding
    // signature or dependencies may have been ignored
    FORCE_INSTALLED = 3;
  }
  // an extension may contain multiple packages
  message Package {
    string name = 1;
    string version = 2;
    string release = 3;
  }
  message Extension {
    string name = 1;
    string version = 2;
    string release = 3;
    string description = 4;
    InstallStatus install_status = 6;

    // install_at_boot is true if the extension is set to be
    // installed on next system reload
    bool install_at_boot = 7;

    // bool indicating if this extension has a valid signature
    bool signature_valid = 8;

    // available is true if the extension file is still available on the system.
    // the extension may be installed but no longer available if the extension file
    // has been removed.
    bool available = 9;

    // any errors attached to this extension
    string errors = 10;
    repeated Package packages = 11;

    // affected_services is a list of the services which can be affected by this
    // extension. This is static information
    repeated string affected_services = 12;

    // services_to_restart is a list of the services which are pending a reload
    // to be finalized.
    // This list will be cleared after a ReloadExtended RPC executes.
    repeated string services_to_restart = 13;
  }
  repeated Extension extensions = 1;

  // extension_directory is a directory where extension files are contained.
  string extension_directory = 2;
}

message FinalizeExtensionsRequest{
}
message FinalizeExtensionsResponse{
}

message UninstallExtensionRequest{
  // name of the extension to be uninstalled
  string name = 1;

  // a boolean indicating whether we should force uninstalling this extension.
  // if set to true, then ignore conflicts and dependencies when uninstalling.
  bool force = 2;
}
message UninstallExtensionResponse{
}

message InstallExtensionResponse{
  enum Operation{
    UNSPECIFIED = 0;
    TRANSFER_COMPLETE = 1;
    INSTALL_COMPLETE = 2;
  }
  Operation acknowledgement = 3;
}

message InstallExtensionRequest{
  oneof request{
    TransferRequest transfer_request = 1;
    InstallRequest install_request = 2;
  }
}

// InstallRequest is a request for installing an extension onto a system.
// The extension is applied to the running configuration.
message InstallRequest{
  // extension_name is the name of the extension to install.
  // This is required because InstallExtension can be called
  // for an extension which is already present on the system
  string extension_name = 1;

  // if this is true, then the system will also
  // ensure that this extension is loaded on boot/reboot
  bool load_after_boot = 3;

  // if this is true, then the system will ignore
  // any errors which could arise from missing dependencies
  bool ignore_dependency_checks = 4;

  enum TrustSource {
    // UNSPECIFIED should be treated as an error.
    UNSPECIFIED = 0;
    // ANY = disable signature verification. Allows any extension
    // (even one with missing/invalid signature) to be installed
    ANY = 1;
    // MANUFACTURER = trust only extensions which have been signed
    // by the device manufacturer to be installed.
    MANUFACTURER = 2;
  }
  oneof signature_verification {
    TrustSource source = 5;
    // trust extensions which are valid according to
    // the SSL profile specified by the ssl_profile_id field.
    // Creating and populating SSL profiles is out of the scope of this
    // service and should be done through some other means (e.g. gNSI Certz).
    string ssl_profile_id = 6;
  }
}

message TransferRequest{
  oneof request {
    // name of the extension  (including the file extension)
    string extension_name = 1;
    // raw byte contents to be streamed into the extension file.
    bytes contents = 2;
    // hash of the file.
    types.HashType hash = 3;
  }
}