syntax = "proto3";

package gnoi.extension;

import "types/types.proto";

option go_package = "github.com/openconfig/gnoi/extension";

option (types.gnoi_version) = "0.1.0";

// Extension is a service for managing extensions on the system.
// An extension is a collection of files (e.g. RPMs, squashfs)
// which are installed to modify the behaviour of the services on the
// system.
// Only one RPC (SetSignatureVerification, FinalizeExtensions,
// InstallExtension, UninstallExtension)
// may be in progress at any given time
service Extension{

  // SetSignatureVerification sets the methods for which the
  // system should verify incoming extensions
  rpc SetSignatureVerification(SigVerificationRequest)
      returns (SigVerificationResponse);

  // FinalizeExtensions reloads any services on the system for
  // which extensions have been installed but which have not yet been
  // reloaded with those extensions.
  // Please note that this may kill the connection if the service
  // hosting the gRPC server reloads so the server is not guaranteed
  // to return a response here.
  rpc FinalizeExtensions(FinalizeExtensionsRequest)
      returns (FinalizeExtensionsResponse);

  // InstallExtension installs a new extension on the system.
  // The new extension may be transferred as part of the RPC.
  //
  // Expected workflows are:
  // 1. To transfer a new extension:
  // client ______________________________________ server
  // TransferRequest (with extension_name set) -->
  // TransferRequest (with contents set)       -->
  // .. repeated TransferRequest with contents are sent
  //  until the file is transferred ..
  // TransferRequest (with hash set)           -->
  // .. server verifies hash matches expected ..
  //                                           <-- InstallExtensionResponse
  //                             (with acknowledgement = TRANSFER_COMPLETE)
  // STREAM END
  //
  // 2. To transfer and install a new extension:
  // client ______________________________________ server
  // TransferRequest (with extension_name set) -->
  // TransferRequest (with contents set)       -->
  // .. repeated TransferRequest with contents are sent
  // until the file is transferred ..
  // TransferRequest (with hash set)           -->
  // .. server verifies hash matches expected ..
  //                                           <-- InstallExtensionResponse
  //                             (with acknowledgement = TRANSFER_COMPLETE)
  // InstallRequest (with extension_name set)  -->
  // (note, other fields may be set )
  // .. server installs extension according to fields.
  //                                           <-- InstallExtensionResponse
  //                              (with acknowledgement = INSTALL_COMPLETE)
  // STREAM END
  //
  // 3. To install a pre-existing extension:
  // client ______________________________________ server
  // InstallRequest (with extension_name set)
  // (note, other fields may be set )          -->
  // .. server installs extension according to fields.
  //                                           <-- InstallExtensionResponse
  //                              (with acknowledgement = INSTALL_COMPLETE)
  // STREAM END
  // Note that all installations will install the extension, but that
  // extension will not be applied until the affected services are reloaded.
  // To reload services after installing extensions, issue a
  // FinalizeExtensions RPC after finishing the InstallExtension RPC.
  rpc InstallExtension(stream InstallExtensionRequest)
      returns (stream InstallExtensionResponse);

  // UninstallExtension uninstalls an extension.
  // It returns an error if the requested extension is not installed.
  rpc UninstallExtension(UninstallExtensionRequest)
      returns (UninstallExtensionResponse);
}

message FinalizeExtensionsRequest{
}
message FinalizeExtensionsResponse{
}

message SigVerificationResponse{
}

message SigVerificationRequest{
  enum TrustSource {
    // UNSPECIFIED should be treated as an error.
    UNSPECIFIED = 0;
    // ANY = disable signature verification. Allows any extension
    // (even one with missing/invalid signature) to be installed
    ANY = 1;
    // MANUFACTURER = trust only extensions which have been signed
    // by the device manufacturer to be installed.
    MANUFACTURER = 2;
    // SSL_PROFILE = trust extensions which are valid according to
    // the SSL profile specified by the ssl_profile_id field.
    // creating and populating SSL profiles is out of the scope of this
    // service and should be done through some other means (e.g. gNSI Certz).
    SSL_PROFILE = 3;
  }
  TrustSource source =  1;

  // Optional ssl_profile_id field, which should be populated only
  // if the source of trust is an SSL profile.
  // The server should ignore this field if source is not SSL_PROFILE
  optional string ssl_profile_id = 2;
}

message UninstallExtensionRequest{
  // name of the extension to be uninstalled
  string name = 1;

  // a boolean indicating whether we should force uninstalling this extension.
  // if set to true, then ignore conflicts and dependencies when uninstalling.
  bool force = 2;
}
message UninstallExtensionResponse{
}

message InstallExtensionResponse{
  enum Operation{
    UNSPECIFIED = 0;
    TRANSFER_COMPLETE = 1;
    INSTALL_COMPLETE = 2;
  }
  Operation acknowledgement = 3;
}

message InstallExtensionRequest{
  oneof request{
    TransferRequest transfer_request = 1;
    InstallRequest install_request = 2;
  }
}

// InstallRequest is a request for installing an extension onto a system.
// The extension is applied to the running configuration.
message InstallRequest{
  // extension_name is the name of the extension to install.
  // This is required because InstallExtension can be called
  // for an extension which is already present on the system
  string extension_name = 1;

  // if this is true, then skip signature verification
  // for this particular extension (i.e. allow missing or invalid signatures)
  bool ignore_signature_verification = 2;

  // if this is true, then the system will also
  // ensure that this extension is loaded on boot/reboot
  bool load_after_boot = 3;

  // if this is true, then the system will ignore
  // any errors which could arise from missing dependencies
  bool ignore_dependency_checks = 4;
}

message TransferRequest{
  oneof request {
    // name of the extension  (including the file extension)
    string extension_name = 1;
    // raw byte contents to be streamed into the extension file.
    bytes contents = 2;
    // hash of the file.
    types.HashType hash = 3;
  }
}